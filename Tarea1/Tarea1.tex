\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{geometry}
\usepackage{color}
\usepackage[spanish]{babel}
\geometry{letterpaper, margin=1in}
\usepackage{listings}
\lstset{
  language=Python,
  basicstyle=\small\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{green},
  stringstyle=\color{red},
  breaklines=true,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  frame=lines
}
\usepackage{setspace} \doublespacing

\title{Tarea 1}
\author{Fernando Cruz Pineda, Edson Rafael Flores Arriola}
\date{\today}
\begin{document}
\maketitle

\begin{enumerate}
\item Muestra una máquina de Turing total con alfabetos de entrada y cinta $\Sigma = \{1,\#\}$ y  $\Gamma=\{1,\#,x,\sqcup \}$, respectivamente, que reconozca el lenguaje:

  $A = \{\alpha \# \beta \gamma | \alpha,\beta,\gamma \in \{1\}^* \land |\alpha| + |\beta| = |\gamma| \}$

  Descrito en palabras, el lenguaje A tiene todas las ternas de enteros en notación unaria tales
que la suma de los dos primeros números es igual al tercer número.
Primero da una descripción de alto nivel de tu máquina (como referencia, toma las descripciones de alto nivel de los ejemplos 3.7 a 3.12 en el libro de Michel Sipser), después da la descripción formal, y finalmente da una explicación de porque la máquina es total y reconoc el lenguaje A.

\begin{description}
\item[Máquina $M$: Con la entrada $w= \alpha \# \beta \# \gamma$] 
\\
   \begin{enumerate}
    \item Mientras queden símbolos en $\alpha$:  
      \begin{enumerate}
        \item Marca un $1$ de $\alpha$.  
        \item Busca y marca un $1$ de $\gamma$.  
        \item Si no hay $1$ disponible en $\gamma$, \textbf{rechaza}.  
      \end{enumerate}
    \item Mientras queden símbolos en $\beta$:  
      \begin{enumerate}
        \item Marca un $1$ de $\beta$.  
        \item Busca y marca un $1$ de $\gamma$.  
        \item Si no hay $1$ disponible en $\gamma$, \textbf{rechaza}.  
      \end{enumerate}
    \item Si, al terminar de marcar todos los $1$ de $\beta$, quedan aún $1$ sin marcar en $\gamma$, \textbf{rechaza}.  
    \item En otro caso, \textbf{acepta}.  
  \end{enumerate}
\end{description}

Descripción formal.
\[
M=(Q,\Sigma,\Gamma,\delta,q_0,q_{\text{acepta}},q_{\text{rechaza}})
\]
con
\[
\Sigma=\{1,\#\},\qquad \Gamma=\{1,\# ,x,\sqcup\},
\]
\[
Q=\{q_0,q_1,q_2,q_3,q_4,q_5,q_6,q_7,q_8,q_9,q_{10},q_{11},q_{revision},q_{acepta},q_{rechaza}\}.
\]


La función de transición \(\delta:Q\times\Gamma\to Q\times\Gamma\times\{L,R\}\) viene dada por:

\[
\begin{array}{ll}
\delta(q_0,1)       = (q_1,\,x,\,R), &
\delta(q_0,x)       = (q_0,\,x,\,R),\\[4pt]
\delta(q_0,\#)      = (q_6,\,\#,\,R), &
\delta(q_0,\sqcup)  = (q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_1,1)       = (q_1,\,1,\,R), &
\delta(q_1,x)       = (q_1,\,x,\,R),\\[4pt]
\delta(q_1,\#)      = (q_2,\,\#,\,R), &
\delta(q_1,\sqcup)  = (q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_2,1)       = (q_2,\,1,\,R), &
\delta(q_2,x)       = (q_2,\,x,\,R),\\[4pt]
\delta(q_2,\#)      = (q_3,\,\#,\,R), &
\delta(q_2,\sqcup)  = (q_{rechaza},\,\sqcup,\,L),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_3,1)       = (q_4,\,x,\,L), &
\delta(q_3,x)       = (q_3,\,x,\,R),\\[4pt]
\delta(q_3,\#)      = (q_{rechaza},\,\#,\,R), &
\delta(q_3,\sqcup)  = (q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_4,1)       = (q_4,\,1,\,L), &
\delta(q_4,x)       = (q_4,\,x,\,L),\\[4pt]
\delta(q_4,\#)      = (q_5,\,\#,\,L), &
\delta(q_4,\sqcup)  = (q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_5,1)       = (q_5,\,1,\,L), &
\delta(q_5,x)       = (q_6,\,x,\,R),\\[4pt]
\delta(q_5,\#)      = (q_5,\,\#,\,L), &
\delta(q_5,\sqcup)  = (q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_6,1)       = (q_0,\,x,\,R), &
\delta(q_6,x)       = (q_6,\,x,\,R),\\[4pt]
\delta(q_6,\#)      = (q_7,\,\#,\,R), &
\delta(q_6,\sqcup)  = (q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_7,1)       = (q_8,\,1,\,R), &
\delta(q_7,x)       = (q_7,\,x,\,R),\\[4pt]
\delta(q_7,\#)      = (q_{revision},\,\#,\,R), &
\delta(q_7,\sqcup)  = (q_8,\,\sqcup,\,L),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_8,1)       = (q_8,\,1,\,R), &
\delta(q_8,x)       = (q_8,\,x,\,R),\\[4pt]
\delta(q_8,\#)      = (q_9,\,\#,\,R), &
\delta(q_8,\sqcup)  = (q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_9,1)       = (q_{10},\,x,\,L), &
\delta(q_9,x)       = (q_9,\,x,\,R),\\[4pt]
\delta(q_9,\#)      = (q_{rechaza},\,\#,\,L), &
\delta(q_9,\sqcup)  = (q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_{10},x)    = (q_{10},\,x,\,L), &
\delta(q_{10},1)    = (q_{10},\,1,\,L),\\[4pt]
\delta(q_{10},\#)   = (q_{11},\,\#,\,L), &
\delta(q_{10},\sqcup)=(q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_{11},x)    = (q_{7},\,x,\,R), &
\delta(q_{11},1)    = (q_{11},\,1,\,L),\\[4pt]
\delta(q_{11},\#)   = (q_{rechaza},\,\#,\,L), &
\delta(q_{10},\sqcup)=(q_{rechaza},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_{revision},x)    = (q_{revision},\,x,\,R), &
\delta(q_{revision},\#)   = (q_{revision},\,\#,\,R),\\[4pt]
\delta(q_{revision},1)    = (q_{rechaza},\,1,\,R), &
\delta(q_{revision},\sqcup)= (q_{acepta},\,\sqcup,\,R),
\end{array}
\]

\[
\begin{array}{ll}
\delta(q_{acepta},a)   = (q_{acepta},\,a,\,R), &
\delta(q_{rechaza},a)  = (q_{rechaza},\,a,\,R),
\end{array}
\qquad\text{para todo }a\in\Gamma.
\]

La máquina es total porque para cada estado y cada símbolo del alfabeto de cinta está definida una transición, ya sea avanzando en el proceso de emparejamiento, regresando para reiniciar la búsqueda o yendo a un estado de aceptación o rechazo, de modo que nunca queda sin movimiento posible. Reconoce el lenguaje \(A\) porque marca sistemáticamente un `1` de \(\alpha\) y un `1` correspondiente de \(\gamma\), luego un `1` de \(\beta\) y un `1` de \(\gamma\); si en algún momento no encuentra un `1` para emparejar, rechaza. Al finalizar, acepta únicamente si todos los `1` de \(\gamma\) han sido emparejados, lo que garantiza que \(|\alpha| + |\beta| = |\gamma|\).


\item Sea $\Sigma$ un alfabeto finito. Demuestra que para todo lenguaje reconocible $A \subseteq \Sigma ^*$ existe una máquina de Turing M tal que L(M) = A y siempre que M rechaza una cadena de entrada $w \in \Sigma ^*$, lo hace entrando en un loop infinito.

  Dem.

  Sea $A \subseteq \Sigma^*$ un lenguaje reconocible cualquiera, esto quiere decir que existe una MT $N = (Q, \Sigma, \Gamma, \delta, q_0, q_{acepta}, q_{rechaza})$, tal que $L(N) = A$.

  Proponemos la siguiente máquina de Turing $M = (Q', \Sigma, \Gamma, \delta_M, q_0, q_{acepta})$ tal que

  $Q' = Q - \{q_{rechaza}\} \cup \{p\}$

  
  $\delta(q,x)_M = $
  \begin{cases}
    (p,a,L) \text{ si } \delta(q,x) = (q_{rechaza},a,L) \\
    (p,a,R) \text{ si } \delta(q,x) = (q_{rechaza},a,R) \\
    (p,x,R) \text{ si } q = p \\
    \delta(q,x)  \text{ en otro caso}
  \end{cases} para cualquier $x,a \in \Sigma$ y $q \in Q'$

  P.d $L(M)=A$

  Procedemos por doble contención
  
  P.d $A \subseteq L(M)$

  Sea $w \in A$ una cadena cualquiera, como A es reconocible, significa que w es aceptada por N. Esto implica que N llega al estado $q_{acepta}$ tras procesar esta cadena. Por la construcción de M, las transiciones de M que conducen a la aceptación son idénticas a las de N. Por lo tanto, si N acepta w, M también lo hará, así $w \in L(M)$

  P.d $L(M) \subseteq A$

  Sea $w \in L(M)$, esto quiere decir que M acepta a w. Por la construcción de M, M acepta si y sólo si N acepta, por lo tanto $w \in L(N) $ pero $L(N)=A$, así $w \in A$.

  Por lo que podemos concluir que $L(M)=A$.

  P.d Cuando M rechaza lo hace entrando a un loop infinito

  Sea w una cadena que es rechazada por N, esto sucede unicamente si la computación de w en N termina en el estado $q_{rechaza}$, ahora, según nuestra construcción de M, cualquier transición en N que hubiera llevado a $q_{rechaza}$ lleva al estado p en M. Una vez en el estado p, según la definición de $\delta_M$, no importa lo que se lea M se va a quedar en p y se va a mover a la derecha sin parar. Dado que p no es un estado de aceptación ni de rechazo, la máquina nunca se detiene. Es decir, se queda en un loop infinito.

  Así podemos concluir que para cualquier lenguaje A reconocible existe una MT M tal que $L(M)=A$ y M rechaza entrando a un loop infinito.
  
\item Sea $\Sigma$ un alfabeto finito. Demuestra que si $A \subseteq \Sigma ^*$ es un lenguaje regular, entonces A es decidible.

  Dem.

  Por hipótesis A es un lenguaje regular, esto quiere decir que existe un AFD $D = (Q,\Sigma,\delta_D,q_0,F)$ tal que $L(D) = A$, ahora, proponemos una MT $M=(Q',\Sigma,\Gamma,\delta_M, q_0, q_{acepta},q_{rechaza})$ tq

  $Q'=Q \cup \{q_{rechaza}, q_{acepta}\}$
  
  $\Gamma = \Sigma \cup \{\sqcup \}$

  $\delta(q,x)_M = $
  \begin{cases}
    (q_{acepta},\sqcup,R) \text{ si } x= \sqcup y q \in F\\
    (q_{rechaza},\sqcup,R) \text{ si } x= \sqcup y q \notin F\\
    (\delta_D(q,x),\sqcup, R\)  \text{ en otro caso}
  \end{cases} para cualquier $x \in \Sigma$ y $q \in Q'$

  P.d M es una MT total que decide a A.

  Para demostrarlo primero vamos a demostrar el siguiente lema

  Lema : Para toda cadena w tras $|w|$ pasos la maquina M se encuentra en el estado $\widehat{\delta_D}(q_0,w)$ y el cabezal está leyendo la casilla inmediata a la derecha.

  Procedemos por inducción sobre $|w|$.

  Caso base: $|w|$ =0, es decir $w=\epsilon$, además tenemos que en 0 pasos seguimos en nuestro estado inicial $q_0$, y usando el caso base de la definición recursiva de $\widehat{\delta_D}(q_0,\epsilon)=q_0$, por lo tanto, se cumple para el caso base.

  H.I El lema se cumple para toda cadena v tal que $|v|$ = n, $n \geq 0$
4
  P.d El lema se cumple para toda cadena w tal que $|w|$ = n+1

  Sea w una cadena cualquiera, podemos verla como la cadena w=va con $v \in \Sigma^*, a \in \Sigma$, tenemos que $|v| = n$ por lo que por H.I tras n pasos estamos en el estado $\widehat{\delta_D}(q_0,v)$ y el cabezal está leyendo a, por lo que en el paso n+1 al aplicar $\delta_M$ tenemos que $\delta_M(\widehat{\delta_D}(q_0,v),a)= (\delta(\widehat{\delta_D}(q_0,v),a),\sqcup,R)$, pero sabemos que por la definición recursiva de $\widehat{\delta_D}$, esto es igual a $\delta_M(\widehat{\delta_D}(q_0,v),a)= ((\widehat{\delta_D}(q_0,w),\sqcup,R)$, es decir, tras n+1 estamos en el estado $\widehat{\delta_D}(q_0,w)$ leyendo la casilla inmediata a la derecha.

  Así queda demostrado el lema.


  Usando el lema anterior, tenemos que para toda cadena w tras $|w|$ pasos el cabezal va a estar leyendo la casilla $\sqcup$ inmediatamente a la derecha del último símbolo de w y estaremos en el estado $\widehat{\delta_D}(q_0,w)$. Ahora en un paso más por definición de nuestra $\delta_M$ entraría en alguno de los dos primeros casos , si $\widehat{\delta_D}(q_0,w) \in F$, entonces M pasa a $q_{acepta}$ y se detiene y si $\widehat{\delta_D}(q_0,w) \notin F$ M pasa a $q_{rechaza}$ deteneniendose rechazando a w. 

  Por lo tanto, tenemos que $w \in A \Leftrightarrow M acepta $ y $w \notin A \Leftrightarrow M rechaza $, en otras palabras M decide A.
  

  
  \end{enumerate}
\end{document}
